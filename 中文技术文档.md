# Multiple Choice Quiz 多选题游戏 - 详细技术文档

## 项目概述

这是一个基于Java Swing的多选题测验游戏，严格遵循Clean Architecture（整洁架构）设计原则。本文档基于`Multiple_Choice_Yihang2`分支的最终源码进行分析。

## 目录

1. [整体架构](#整体架构)
2. [Clean Architecture实现](#clean-architecture实现)
3. [数据流分析](#数据流分析)
4. [用户流分析](#用户流分析)
5. [详细类说明](#详细类说明)
6. [方法间协调机制](#方法间协调机制)
7. [Yihang在Jiayi基础上的改动](#yihang在jiayi基础上的改动)

---

## 整体架构

### 项目结构

```
src/main/java/com/csc207/arcade/multiplechoice/
├── app/                          # 应用层
│   └── Main.java                 # 程序入口
├── entities/                     # 实体层（核心业务逻辑）
│   ├── QuizQuestion.java         # 问题实体
│   └── QuizSession.java          # 测验会话实体
├── use_case/                     # 用例层（应用业务逻辑）
│   ├── QuestionDAI.java          # 数据访问接口
│   ├── quiz/                     # 开始测验用例
│   │   ├── QuizInputBoundary.java
│   │   ├── QuizInputData.java
│   │   ├── QuizOutputBoundary.java
│   │   ├── QuizOutputData.java
│   │   └── QuizInteractor.java
│   └── submit/                   # 提交答案用例
│       ├── SubmitAnswerInputBoundary.java
│       ├── SubmitAnswerInputData.java
│       ├── SubmitAnswerOutputBoundary.java
│       ├── SubmitAnswerOutputData.java
│       └── SubmitAnswerInteractor.java
├── interface_adapter/            # 接口适配器层
│   ├── QuizController.java       # 控制器
│   ├── QuizPresenter.java        # 展示器
│   ├── QuizViewModel.java        # 视图模型（Quiz视图）
│   └── ResultsViewModel.java     # 视图模型（结果视图）
├── data_access/                  # 数据访问层
│   └── QuestionDAO.java          # 问题数据访问对象
└── view/                         # 视图层
    ├── CategorySelectionView.java # 类别选择视图
    ├── QuizView.java              # 测验视图
    ├── ResultsView.java           # 结果视图
    └── ScaledImagePanel.java      # 缩放图片面板组件

src/main/resources/
└── data/
    ├── questions.json             # 问题数据
    └── images/                    # 问题图片资源
```

---

## Clean Architecture实现

本项目严格遵循Clean Architecture的分层原则，从内到外分为四层：

### 1. 实体层（Entities Layer）- 最内层

**位置**: `entities/`

**职责**: 
- 封装企业级业务规则和核心业务逻辑
- 独立于任何外部框架或技术
- 不依赖于任何其他层

**核心类**:
- `QuizQuestion`: 表示单个测验问题
- `QuizSession`: 管理整个测验会话的状态

### 2. 用例层（Use Cases Layer）

**位置**: `use_case/`

**职责**:
- 实现应用特定的业务规则
- 协调实体对象完成用例
- 定义输入/输出边界（接口），实现依赖倒置

**核心组件**:
- `QuizInteractor`: 处理开始测验的用例
- `SubmitAnswerInteractor`: 处理提交答案的用例
- `QuestionDAI`: 数据访问接口（依赖倒置原则）

### 3. 接口适配器层（Interface Adapters Layer）

**位置**: `interface_adapter/` 和 `data_access/`

**职责**:
- 将数据从用例层的格式转换为外层（UI/数据库）的格式
- Controller接收UI事件并调用用例
- Presenter将用例输出格式化为UI可用的数据
- ViewModel存储UI状态数据

**核心类**:
- `QuizController`: 接收UI动作，调用用例
- `QuizPresenter`: 格式化用例输出，更新ViewModel
- `QuizViewModel`, `ResultsViewModel`: 存储视图状态
- `QuestionDAO`: 实现数据访问接口

### 4. 框架和驱动层（Frameworks & Drivers Layer）- 最外层

**位置**: `view/` 和 `app/`

**职责**:
- UI框架（Swing组件）
- 应用程序启动和依赖注入
- 外部资源访问

**核心类**:
- `Main`: 程序入口，依赖注入
- `CategorySelectionView`: 类别选择界面
- `QuizView`: 测验界面
- `ResultsView`: 结果显示界面

### 依赖规则

```
外层 → 内层 (允许)
内层 → 外层 (禁止)

View → Controller → Interactor → Entity
     ↓           ↓
  ViewModel  ← Presenter
```

**关键设计模式**:
1. **依赖倒置（Dependency Inversion）**: 用例层定义接口（如`QuestionDAI`），外层实现
2. **边界接口（Boundary）**: InputBoundary和OutputBoundary定义层间通信
3. **数据传输对象（DTO）**: InputData和OutputData用于跨层数据传输

---

## 数据流分析

### 1. 启动流程数据流

```
Main.main()
  ↓
创建QuestionDAO实例并加载数据
  ↓ (从JSON文件读取)
QuestionDAO.loadData()
  ↓ (解析JSON)
allQuestions列表填充
  ↓
创建ViewModels (QuizViewModel, ResultsViewModel)
  ↓
创建Presenter (连接ViewModels)
  ↓
创建Interactors (QuizInteractor, SubmitAnswerInteractor)
  ↓
创建Controller (连接Interactors)
  ↓
创建Views (CategorySelectionView, QuizView, ResultsView)
  ↓
显示CategorySelectionView
```

### 2. 开始测验数据流

```
用户点击"start"按钮
  ↓
CategorySelectionView.actionPerformed()
  ↓
QuizController.startQuiz(category)
  ↓ (创建QuizInputData对象)
QuizInteractor.execute(QuizInputData)
  ↓ (调用数据访问层)
QuestionDAO.getCategorizedQuestions(category)
  ↓ (过滤问题列表)
返回List<QuizQuestion>
  ↓ (创建会话)
new QuizSession(questions)
  ↓ (获取第一个问题)
currentSession.getCurrentQuestion()
  ↓ (创建输出数据)
new QuizOutputData(imagePath, progressLabel)
  ↓
QuizPresenter.prepareQuizView(QuizOutputData)
  ↓ (更新视图模型)
QuizViewModel.setCurrentImagePath()
QuizViewModel.setQuestionProgressLabel()
  ↓ (触发PropertyChange事件)
QuizView.propertyChange()
  ↓ (更新UI组件)
imagePanel.setImage()
progressLabel.setText()
```

### 3. 提交答案数据流

```
用户点击答案按钮(A/B/C/D)
  ↓
QuizView.buttonX.actionPerformed()
  ↓
QuizController.submitAnswer(selectedAnswer)
  ↓ (创建输入数据)
new SubmitAnswerInputData(selectedAnswer)
  ↓
SubmitAnswerInteractor.execute(SubmitAnswerInputData)
  ↓ (获取当前问题)
quizSession.getCurrentQuestion()
  ↓ (比较答案)
selectedAnswer.equals(correctAnswer)
  ↓
如果正确:
  quizSession.recordAnswer(true)
  ↓
  new SubmitAnswerOutputData(true, ...)
  ↓
  SubmitAnswerPresenter.prepareSuccessView()
  ↓
  QuizViewModel.setFeedbackState("CORRECT")
  QuizViewModel.setIncorrectButton(selectedAnswer)
  ↓
  QuizView.handleFeedbackState()
  ↓
  按钮变绿色
  ↓
  启动1秒Timer
  ↓
  QuizController.nextQuestion()
  ↓
  SubmitAnswerInteractor.advance()
  ↓
  quizSession.advanceToNextQuestion()
  ↓
  加载下一个问题或显示结果

如果错误:
  quizSession.recordAnswer(false)
  ↓
  new SubmitAnswerOutputData(false, ...)
  ↓
  SubmitAnswerPresenter.prepareFailView()
  ↓
  QuizViewModel.setFeedbackState("INCORRECT")
  QuizViewModel.setIncorrectButton(selectedAnswer)
  ↓
  QuizView.handleFeedbackState()
  ↓
  按钮变红色
  ↓
  用户可以继续尝试其他答案
```

### 4. 显示结果数据流

```
最后一个问题回答正确后
  ↓
SubmitAnswerInteractor.advance()
  ↓
quizSession.advanceToNextQuestion() 返回false
  ↓
quizSession.finishQuiz() (记录结束时间)
  ↓
计算accuracy和totalTime
  ↓
SubmitAnswerPresenter.prepareResultsView(accuracy, totalTime)
  ↓
ResultsViewModel.setAccuracy()
ResultsViewModel.setTotalTimeMs()
  ↓ (触发PropertyChange事件)
Main中的监听器捕获
  ↓
关闭QuizView
显示ResultsView
```

---

## 用户流分析

### 完整用户体验流程

```
[启动应用]
    ↓
[CategorySelectionView显示]
- 显示标题: "choose a module"
- 显示6个单选按钮: Module 0-5
- 显示"start"按钮
    ↓
[用户选择模块]
- 用户点击某个Module单选按钮
    ↓
[用户点击start按钮]
    ↓
[验证选择]
- 如果没有选择: 弹出提示"请先选择一个模块"
- 如果已选择: 继续
    ↓
[加载对应模块的问题]
    ↓
[CategorySelectionView关闭]
[QuizView显示]
- 顶部显示问题图片
- 中间显示进度标签: "Question 1/N"
- 底部显示4个答案按钮: A, B, C, D
    ↓
[用户查看问题图片]
    ↓
[用户点击答案按钮]
    ↓
[答案验证 - 场景1: 答案正确]
- 选中的按钮变为绿色
- 等待1秒
- 自动进入下一题
    ↓
[答案验证 - 场景2: 答案错误]
- 选中的按钮变为红色
- 用户可以继续尝试其他选项
- 选择正确答案后才能进入下一题
- 注意: 首次尝试错误会影响最终得分
    ↓
[循环: 完成所有问题]
    ↓
[最后一题回答正确]
    ↓
[QuizView关闭]
[ResultsView显示]
- 显示标题: "Quiz Complete!"
- 显示准确率: "Accuracy: XX%"
- 显示总用时: "Time: XX.XX seconds"
- 显示"Close"按钮
    ↓
[用户点击Close或关闭窗口]
    ↓
[应用退出]
```

### 关键用户交互点

1. **类别选择阶段**
   - 交互: 单选按钮选择 + 确认按钮
   - 验证: 必须选择一个选项才能继续
   - 反馈: 错误提示对话框

2. **答题阶段**
   - 交互: 点击A/B/C/D按钮
   - 反馈: 
     - 正确: 绿色高亮 + 自动前进
     - 错误: 红色高亮 + 允许重试
   - 进度显示: 实时更新"Question X/N"

3. **结果展示阶段**
   - 显示: 准确率和总时间
   - 交互: 关闭按钮退出应用

---

## 详细类说明

### 实体层（Entities）

#### QuizQuestion.java

**职责**: 表示一个测验问题的数据结构

**属性**:
```java
- String questionId      // 问题唯一标识
- String imagePath       // 问题图片路径
- String category        // 问题类别（模块）
- String correctAnswer   // 正确答案（A/B/C/D）
```

**关键方法**:
- `QuizQuestion()`: 无参构造器，用于JSON反序列化
- `QuizQuestion(String, String, String, String)`: 完整构造器
- `normalize(String)`: 私有方法，标准化字符串（trim空格）
- `getters/setters`: 标准访问器方法

**设计考虑**:
- 不包含任何业务逻辑，纯数据对象
- `normalize`方法确保category数据一致性
- 支持JSON序列化/反序列化

#### QuizSession.java

**职责**: 管理单次测验的状态和业务逻辑

**属性**:
```java
- List<QuizQuestion> questions                  // 问题列表
- int currentQuestionIndex                      // 当前问题索引
- int correctAnswersCount                       // 正确答案计数
- long startTime                                // 开始时间戳
- long endTime                                  // 结束时间戳
- boolean currentQuestionAnsweredIncorrectly    // 当前问题是否答错过
```

**核心方法**:

1. `QuizSession(List<QuizQuestion> questions)`
   - 初始化测验会话
   - 记录开始时间
   - 设置初始状态

2. `QuizQuestion getCurrentQuestion()`
   - 返回当前问题
   - 如果索引越界返回null

3. `void recordAnswer(boolean isCorrect)`
   - 记录答案结果
   - **关键逻辑**: 只在首次尝试时计分
   - 如果答错，标记`currentQuestionAnsweredIncorrectly = true`
   - 后续答对不再增加分数

4. `boolean advanceToNextQuestion()`
   - 移动到下一个问题
   - 重置`currentQuestionAnsweredIncorrectly`标志
   - 返回是否还有更多问题

5. `boolean isQuizOver()`
   - 检查测验是否结束

6. `double getAccuracy()`
   - 计算准确率: correctAnswersCount / totalQuestions
   - 返回0.0到1.0之间的值

7. `long getTotalTime()`
   - 计算总用时（毫秒）: endTime - startTime

8. `void finishQuiz()`
   - 记录结束时间戳

**设计亮点**:
- 封装了测验的核心业务规则
- 首次尝试计分机制防止重复计分
- 时间追踪功能
- 完全独立于UI和框架

---

### 用例层（Use Cases）

#### QuestionDAI.java (Data Access Interface)

**职责**: 定义数据访问的契约（依赖倒置）

**接口方法**:
```java
void loadData()                                        // 加载数据
List<QuizQuestion> getCategorizedQuestions(String)    // 获取指定类别的问题
```

**设计目的**:
- 用例层不依赖具体实现
- 外层（data_access）实现此接口
- 便于测试（可以mock）

#### Quiz用例 - 开始测验

**QuizInputBoundary.java**
```java
public interface QuizInputBoundary {
    void execute(QuizInputData inputData);
}
```
- 定义用例的输入接口

**QuizInputData.java**
```java
private String category;  // 用户选择的类别
```
- 封装用例输入数据

**QuizOutputBoundary.java**
```java
public interface QuizOutputBoundary {
    void prepareQuizView(QuizOutputData data);
}
```
- 定义用例的输出接口
- Presenter实现此接口

**QuizOutputData.java**
```java
private String imagePath;         // 问题图片路径
private String questionProgress;  // 进度标签文本
```
- 封装用例输出数据

**QuizInteractor.java**

**职责**: 实现开始测验的业务逻辑

**属性**:
```java
private final QuestionDAI questionDAO;
private final QuizOutputBoundary quizPresenter;
private QuizSession currentSession;
```

**核心方法**:

`void execute(QuizInputData inputData)`
```java
1. 获取用户选择的类别
2. 调用questionDAO获取该类别的问题列表
3. 创建新的QuizSession对象
4. 获取第一个问题
5. 构建QuizOutputData（包含图片路径和进度）
6. 调用presenter.prepareQuizView(outputData)
```

`QuizSession getCurrentSession()`
- 返回当前会话对象
- 供SubmitAnswerInteractor使用

**设计要点**:
- 不知道数据来源（通过QuestionDAI抽象）
- 不知道如何展示（通过QuizOutputBoundary抽象）
- 纯粹的业务逻辑协调

#### Submit用例 - 提交答案

**SubmitAnswerInputBoundary.java**
```java
public interface SubmitAnswerInputBoundary {
    void execute(SubmitAnswerInputData inputData);
}
```

**SubmitAnswerInputData.java**
```java
private String selectedAnswer;  // 用户选择的答案(A/B/C/D)
```

**SubmitAnswerOutputBoundary.java**
```java
public interface SubmitAnswerOutputBoundary {
    void prepareSuccessView(SubmitAnswerOutputData data);
    void prepareFailView(SubmitAnswerOutputData data);
    void prepareResultsView(double accuracy, long totalTimeMs);
}
```

**SubmitAnswerOutputData.java**
```java
private boolean isCorrect;        // 答案是否正确
private String selectedAnswer;    // 用户选择的答案
private String correctAnswer;     // 正确答案
```

**SubmitAnswerInteractor.java**

**职责**: 处理答案提交和测验推进逻辑

**属性**:
```java
private final QuizSession quizSession;
private final SubmitAnswerOutputBoundary submitAnswerPresenter;
private final QuizOutputBoundary quizPresenter;
```

**核心方法**:

1. `void execute(SubmitAnswerInputData inputData)`
```java
流程:
1. 获取用户选择的答案
2. 获取当前问题及其正确答案
3. 比较答案是否正确
4. 创建SubmitAnswerOutputData
5. 如果正确:
   - quizSession.recordAnswer(true)
   - submitAnswerPresenter.prepareSuccessView(outputData)
6. 如果错误:
   - quizSession.recordAnswer(false)
   - submitAnswerPresenter.prepareFailView(outputData)
```

2. `void advance()`
```java
流程:
1. 调用quizSession.advanceToNextQuestion()
2. 如果还有更多问题:
   - 获取下一个问题
   - 构建QuizOutputData
   - 调用quizPresenter.prepareQuizView(outputData)
3. 如果测验结束:
   - quizSession.finishQuiz()
   - 计算accuracy和totalTime
   - 调用submitAnswerPresenter.prepareResultsView(accuracy, totalTime)
```

**设计亮点**:
- 分离了答案验证和前进逻辑
- 答案正确时由View延迟调用advance()（显示1秒绿色反馈）
- 同时依赖两个Presenter接口处理不同输出场景

---

### 接口适配器层（Interface Adapters）

#### QuizController.java

**职责**: 接收View层的用户操作，转换为用例调用

**属性**:
```java
private final QuizInteractor quizInteractor;
private SubmitAnswerInteractor submitAnswerInteractor;
```

**方法**:

1. `void startQuiz(String category)`
   - 创建QuizInputData对象
   - 调用quizInteractor.execute()

2. `void setSubmitAnswerInteractor(SubmitAnswerInteractor)`
   - 延迟设置（需要先有QuizSession）

3. `boolean hasSubmitAnswerInteractor()`
   - 检查是否已设置

4. `void submitAnswer(String answer)`
   - 创建SubmitAnswerInputData对象
   - 调用submitAnswerInteractor.execute()

5. `void nextQuestion()`
   - 调用submitAnswerInteractor.advance()

**设计特点**:
- 不依赖Presenter（单向依赖）
- 不包含业务逻辑，只做转换
- SubmitAnswerInteractor延迟注入（因为需要QuizSession）

#### QuizPresenter.java

**职责**: 将用例输出转换为ViewModel可用的格式

**实现接口**: 
- `QuizOutputBoundary`
- `SubmitAnswerOutputBoundary`

**属性**:
```java
private final QuizViewModel quizViewModel;
private final ResultsViewModel resultsViewModel;
```

**方法**:

1. `void prepareQuizView(QuizOutputData data)`
```java
- quizViewModel.setCurrentImagePath(data.getImagePath())
- quizViewModel.setQuestionProgressLabel(data.getQuestionProgress())
- quizViewModel.setIncorrectButton(null)  // 重置反馈状态
- quizViewModel.setFeedbackState("NONE")
```

2. `void prepareSuccessView(SubmitAnswerOutputData data)`
```java
- quizViewModel.setIncorrectButton(data.getSelectedAnswer())
- quizViewModel.setFeedbackState("CORRECT")
```

3. `void prepareFailView(SubmitAnswerOutputData data)`
```java
- quizViewModel.setIncorrectButton(data.getSelectedAnswer())
- quizViewModel.setFeedbackState("INCORRECT")
```

4. `void prepareResultsView(double accuracy, long totalTimeMs)`
```java
- resultsViewModel.setAccuracy(accuracy)
- resultsViewModel.setTotalTimeMs(totalTimeMs)
```

**设计要点**:
- 作为用例层和View层之间的桥梁
- 不包含业务逻辑，只做数据格式转换
- 通过ViewModel与View解耦

#### QuizViewModel.java

**职责**: 存储QuizView的状态数据

**继承**: `PropertyChangeSupport`机制

**属性**:
```java
private String currentImagePath;        // 当前问题图片路径
private String questionProgressLabel;   // 进度文本
private String feedbackState;           // 反馈状态: NONE/CORRECT/INCORRECT
private String incorrectButton;         // 需要高亮的按钮
```

**方法**: 
- 标准的getters/setters
- 每个setter调用`firePropertyChange()`通知View更新

**观察者模式**:
- View注册为PropertyChangeListener
- ViewModel状态改变时自动通知View

#### ResultsViewModel.java

**职责**: 存储ResultsView的状态数据

**属性**:
```java
private double accuracy;     // 准确率(0.0-1.0)
private long totalTimeMs;    // 总用时(毫秒)
```

**方法**: 
- 标准的getters/setters
- 每个setter调用`firePropertyChange()`

---

### 数据访问层（Data Access）

#### QuestionDAO.java

**职责**: 实现QuestionDAI接口，从JSON文件加载问题数据

**实现接口**: `QuestionDAI`

**属性**:
```java
private List<QuizQuestion> allQuestions = new ArrayList<>();
private boolean loaded = false;
```

**核心方法**:

1. `void loadData()`
```java
流程:
1. 检查是否已加载（loaded标志）
2. 从classpath读取"data/questions.json"
3. 使用org.json库解析JSON数组
4. 遍历JSON对象，创建QuizQuestion实例
5. 填充allQuestions列表
6. 设置loaded = true
7. 错误处理: 打印错误信息，设置空列表
```

2. `List<QuizQuestion> getCategorizedQuestions(String category)`
```java
流程:
1. 确保数据已加载（调用loadData()）
2. 遍历allQuestions
3. 过滤出category匹配的问题
4. 返回结果列表
```

**设计考虑**:
- 懒加载机制（loaded标志）
- 简单的内存缓存（allQuestions）
- 错误处理健壮
- 符合依赖倒置原则（实现用例层定义的接口）

---

### 视图层（View）

#### CategorySelectionView.java

**职责**: 显示类别选择界面

**继承**: `JFrame implements PropertyChangeListener`

**UI组件**:
```java
private JRadioButton[] options;  // 6个单选按钮(Module 0-5)
private JButton submit;          // "start"按钮
```

**布局**:
- BorderLayout
- NORTH: 标题标签 "choose a module"
- CENTER: 单选按钮面板
- SOUTH: 提交按钮

**关键逻辑**:

`submit按钮的ActionListener`:
```java
1. 遍历单选按钮
2. 找到被选中的按钮
3. 调用quizController.startQuiz(选中的文本)
4. 如果没有选择，弹出对话框提示"请先选择一个模块"
```

**生命周期**:
- Main中监听quizViewModel的"imagePath"属性变化
- 当imagePath更新时，dispose此View并显示QuizView

#### QuizView.java

**职责**: 显示测验问题和答案按钮

**继承**: `JFrame implements PropertyChangeListener`

**UI组件**:
```java
private ScaledImagePanel imagePanel;  // 自定义图片面板
private JLabel progressLabel;         // 进度标签
private JButton buttonA, buttonB, buttonC, buttonD;  // 答案按钮
private Timer autoAdvanceTimer;       // 自动前进定时器
```

**布局**:
- BorderLayout
- CENTER: 图片面板（问题图片）
- SOUTH: bottomPanel
  - NORTH: 进度标签
  - CENTER: 按钮面板（2x2 GridLayout）

**关键方法**:

1. `void propertyChange(PropertyChangeEvent evt)`
```java
监听ViewModel的三个属性:
- "imagePath": 更新imagePanel显示的图片
- "progressLabel": 更新进度文本
- "feedbackState": 调用handleFeedbackState()
```

2. `void handleFeedbackState()`
```java
根据feedbackState的值:
- "INCORRECT":
  * resetButtonColors()
  * 将incorrectButton设置为红色
- "CORRECT":
  * resetButtonColors()
  * 将selectedButton设置为绿色
  * 启动1秒Timer
  * Timer到期后调用controller.nextQuestion()
- "NONE":
  * resetButtonColors()
```

3. `void setButtonColor(String button, Color color)`
   - 根据按钮名称(A/B/C/D)设置对应按钮的背景色

4. `void resetButtonColors()`
   - 将所有按钮恢复为默认颜色

**答案按钮ActionListener**:
```java
buttonA.addActionListener(e -> controller.submitAnswer("A"));
buttonB.addActionListener(e -> controller.submitAnswer("B"));
buttonC.addActionListener(e -> controller.submitAnswer("C"));
buttonD.addActionListener(e -> controller.submitAnswer("D"));
```

**设计亮点**:
- 使用Timer实现延迟自动前进
- 颜色反馈清晰直观
- 完全由ViewModel驱动更新（观察者模式）

#### ResultsView.java

**职责**: 显示测验结果

**继承**: `JFrame implements PropertyChangeListener`

**UI组件**:
- 标题标签: "Quiz Complete!"
- 准确率标签
- 时间标签
- 关闭按钮

**关键逻辑**:

`void propertyChange(PropertyChangeEvent evt)`
```java
监听ResultsViewModel的属性变化:
- "accuracy": 更新准确率显示 (格式化为百分比)
- "totalTimeMs": 更新时间显示 (转换为秒)
```

#### ScaledImagePanel.java

**职责**: 自动缩放图片以适应面板大小的自定义组件

**继承**: `JPanel`

**关键方法**:

1. `void setImage(String imagePath)`
   - 从resources加载图片
   - 触发重绘

2. `void paintComponent(Graphics g)`
   - 计算缩放比例（保持宽高比）
   - 居中绘制图片

**设计目的**:
- 确保不同大小的问题图片都能正常显示
- 提升用户体验

---

### 应用层（App）

#### Main.java

**职责**: 
- 应用程序入口
- 依赖注入和对象组装
- 设置View间的切换逻辑

**main方法流程**:

```java
1. 创建QuestionDAO并加载数据
   QuestionDAI repository = new QuestionDAO();
   repository.loadData();

2. 创建ViewModels
   QuizViewModel quizViewModel = new QuizViewModel();
   ResultsViewModel resultsViewModel = new ResultsViewModel();

3. 创建Presenter（连接ViewModels）
   QuizPresenter presenter = new QuizPresenter(quizViewModel, resultsViewModel);

4. 创建QuizInteractor（连接repository和presenter）
   QuizInteractor quizInteractor = new QuizInteractor(repository, presenter);

5. 创建Controller
   QuizController quizController = new QuizController(quizInteractor);

6. 创建Views
   CategorySelectionView selectionView = new CategorySelectionView(quizViewModel);
   selectionView.setQuizController(quizController);
   QuizView quizView = new QuizView(quizController, quizViewModel);
   ResultsView resultsView = new ResultsView(resultsViewModel);

7. 设置quizViewModel的监听器
   - 监听"imagePath"属性变化
   - 当imagePath更新时:
     * 创建SubmitAnswerInteractor（需要quizInteractor.getCurrentSession()）
     * 将其注入到quizController
     * 关闭selectionView，显示quizView

8. 设置resultsViewModel的监听器
   - 监听"accuracy"和"totalTimeMs"属性变化
   - 当这些属性更新时:
     * 关闭quizView
     * 显示resultsView

9. 显示CategorySelectionView（初始界面）
   selectionView.setVisible(true);
```

**设计特点**:
- 集中的依赖注入
- 使用PropertyChangeListener实现View切换
- 延迟创建SubmitAnswerInteractor（需要QuizSession）
- 清晰的对象生命周期管理

---

## 方法间协调机制

### 1. 依赖注入协调

**在Main类中集中组装**:
```
QuestionDAO → QuizInteractor → QuizController
                ↓
            QuizPresenter → QuizViewModel → QuizView
                ↓
         ResultsViewModel → ResultsView
```

**延迟注入**:
- SubmitAnswerInteractor在QuizSession创建后才注入
- 原因: 需要quizInteractor.getCurrentSession()

### 2. 观察者模式协调

**ViewModel作为Subject**:
```
QuizViewModel
  ↓ (firePropertyChange)
QuizView.propertyChange()
  ↓
更新UI组件
```

**多个Observer**:
- QuizView监听QuizViewModel
- ResultsView监听ResultsViewModel
- Main中的匿名监听器处理View切换

### 3. 边界接口协调

**用例层与外层解耦**:
```
Controller → InputBoundary → Interactor → OutputBoundary → Presenter
```

**数据传输对象（DTO）**:
- InputData: Controller → Interactor
- OutputData: Interactor → Presenter
- 确保层间数据独立，避免泄露内部实现

### 4. 事件驱动协调

**用户操作流**:
```
用户点击按钮
  ↓ (Swing ActionListener)
View方法
  ↓
Controller方法
  ↓
Interactor.execute()
  ↓
Presenter.prepare___View()
  ↓
ViewModel.set___()
  ↓ (PropertyChange事件)
View.propertyChange()
  ↓
更新UI
```

### 5. Timer协调机制

**答案正确后的延迟前进**:
```
用户选择正确答案
  ↓
SubmitAnswerInteractor.execute()
  ↓
Presenter.prepareSuccessView()
  ↓
QuizView.handleFeedbackState()
  ↓
按钮变绿
  ↓
启动1秒Timer
  ↓ (1秒后)
Timer触发
  ↓
controller.nextQuestion()
  ↓
SubmitAnswerInteractor.advance()
```

### 6. 会话状态协调

**QuizSession的角色**:
- 由QuizInteractor创建和管理
- 传递给SubmitAnswerInteractor使用
- 维护整个测验的状态
- 确保答案记录和进度管理的一致性

### 7. 错误处理协调

**分层错误处理**:
- **数据层**: QuestionDAO捕获IO和JSON解析异常，打印错误，返回空列表
- **用例层**: 假设数据有效，专注业务逻辑
- **View层**: 用户输入验证（如类别选择）

---

## Yihang在Jiayi基础上的改动

基于`git diff Multiple_Choises_Jiayi..Multiple_Choice_Yihang2`的分析：

### 主要改动总结

| 改动类型 | 文件数 | 说明 |
|---------|--------|------|
| 新增文件 | 2 | CategorySelectionView.java, QuestionDAO.java |
| 删除文件 | 3 | AppBuilder.java, DataInitializer.java, JsonQuestionRepository.java |
| 重构文件 | 8 | Main.java及其他核心类 |
| 数据文件 | 1 | questions.json |

### 详细改动分析

#### 1. 架构简化

**删除的文件**:
- `AppBuilder.java`: 复杂的应用构建器
- `DataInitializer.java`: 数据初始化工具（可能用于生成图片）
- `JsonQuestionRepository.java`: 旧的数据仓库实现

**影响**:
- 简化了应用启动逻辑
- 移除了不必要的抽象层
- Main类直接进行依赖注入，更清晰

#### 2. 新增类别选择功能

**新增文件**: `CategorySelectionView.java`

**功能**:
- 允许用户在开始测验前选择类别（Module 0-5）
- 改进了用户体验，提供了更多控制

**集成方式**:
- 作为初始View显示
- 选择类别后才加载对应问题
- 完成选择后切换到QuizView

#### 3. 数据访问层重构

**变更**: `JsonQuestionRepository.java` → `QuestionDAO.java`

**改进**:
- 更简单的实现
- 移除了复杂的依赖
- 更直接的JSON解析逻辑
- 添加了分类获取方法 `getCategorizedQuestions(String category)`

**接口变更**: `QuestionRepository` → `QuestionDAI`

**新方法**:
```java
// 旧接口（可能）
List<QuizQuestion> getQuestions(int count);  // 随机获取N个问题

// 新接口
List<QuizQuestion> getCategorizedQuestions(String category);  // 按类别获取
```

#### 4. Main.java大幅简化

**代码行数**: 从约122行减少到65行

**主要变化**:
- 移除了复杂的QuizControllerWrapper内部类
- 移除了注释掉的旧代码
- 更清晰的依赖注入流程
- 使用Lambda表达式替代匿名内部类
- 添加了CategorySelectionView的集成逻辑

**旧代码模式**（注释部分）:
```java
// 创建wrapper处理延迟初始化
QuizControllerWrapper controllerWrapper = new QuizControllerWrapper();
// ... 复杂的生命周期管理
```

**新代码模式**:
```java
// 直接创建，延迟注入SubmitAnswerInteractor
QuizController quizController = new QuizController(quizInteractor);
// ... 在适当时机注入
quizController.setSubmitAnswerInteractor(submitAnswerInteractor);
```

#### 5. QuizInteractor重构

**输入数据变化**:
```java
// 旧: QuizInputData() - 无参数
// 新: QuizInputData(String category) - 接收类别参数
```

**用例执行变化**:
```java
// 旧
List<QuizQuestion> questions = questionDAO.getQuestions(10);

// 新
String category = inputData.getCategory();
List<QuizQuestion> questions = questionDAO.getCategorizedQuestions(category);
```

**影响**:
- 支持按类别加载问题
- 更灵活的问题选择机制

#### 6. QuizController简化

**变更**:
- 移除了对Presenter的直接依赖
- 简化了构造器
- 添加了`hasSubmitAnswerInteractor()`检查方法

**旧代码**（可能）:
```java
public QuizController(QuizInteractor quizInteractor, 
                      SubmitAnswerInteractor submitAnswerInteractor) {
    // 构造时需要两个Interactor
}
```

**新代码**:
```java
public QuizController(QuizInteractor quizInteractor) {
    // 只需要QuizInteractor
    // SubmitAnswerInteractor延迟注入
}
```

#### 7. QuizPresenter改进

**改动**:
- `prepareQuizView()`方法中增加了反馈状态重置
- 确保每次加载新问题时清除之前的UI状态

**新增逻辑**:
```java
@Override
public void prepareQuizView(QuizOutputData data) {
    quizViewModel.setCurrentImagePath(data.getImagePath());
    quizViewModel.setQuestionProgressLabel(data.getQuestionProgress());
    
    // 新增: 重置反馈状态
    quizViewModel.setIncorrectButton(null);
    quizViewModel.setFeedbackState("NONE");
}
```

#### 8. QuizQuestion实体简化

**变更**:
- 移除了一些可能的冗余字段
- 添加了`normalize()`私有方法处理category
- 简化了构造器逻辑

#### 9. SubmitAnswerInteractor微调

**注释改进**:
- 添加了更详细的注释说明
- 明确了advance()方法的调用时机
- 强调了延迟调用机制

#### 10. QuizView优化

**改动**:
- 改进了`handleFeedbackState()`方法的逻辑
- 确保颜色重置和设置的顺序正确
- Timer逻辑更清晰

#### 11. questions.json数据重构

**变更**:
- 添加了category字段
- 调整了问题的组织方式
- 按Module 0-5分类
- 每个Module 2个问题（共12个问题）

**旧格式**（推测）:
```json
{
  "questionId": "id1",
  "imagePath": "...",
  "correctAnswer": "B"
}
```

**新格式**:
```json
{
  "questionId": "id1",
  "category": "Module 0",
  "imagePath": "...",
  "correctAnswer": "B"
}
```

### 改动的设计意图

#### 提升可维护性
- 删除复杂的AppBuilder和DataInitializer
- 简化Main类的依赖注入逻辑
- 更清晰的职责划分

#### 增强用户体验
- 新增类别选择界面
- 用户可以选择特定模块进行练习
- 更好的反馈状态管理

#### 改进架构
- 更符合Clean Architecture原则
- 减少不必要的抽象层
- 接口命名更规范（QuestionDAI vs QuestionRepository）

#### 数据管理优化
- 支持分类问题加载
- 更灵活的数据访问方式
- 简化的DAO实现

### 改动对Clean Architecture的影响

**保持了Clean Architecture的核心原则**:
1. ✅ 依赖规则: 外层依赖内层，内层不知道外层
2. ✅ 边界接口: InputBoundary和OutputBoundary保持不变
3. ✅ 实体独立性: QuizQuestion和QuizSession仍然是纯业务对象
4. ✅ 用例层抽象: Interactor不依赖具体实现

**改进了架构质量**:
- 减少了过度设计（删除AppBuilder）
- 保持了测试性（通过接口抽象）
- 提升了可读性（简化Main类）
- 增强了灵活性（分类加载机制）

### 潜在的改进建议

虽然Yihang的改动整体上是积极的，但仍有一些可以继续优化的地方：

1. **延迟注入问题**: SubmitAnswerInteractor的延迟注入可以通过工厂模式或依赖注入容器更优雅地解决

2. **View切换逻辑**: Main类中的View切换监听器可以提取为专门的类

3. **错误处理**: 可以添加更多的错误处理逻辑，特别是在加载问题时

4. **测试**: 应该添加单元测试验证改动

---

## 总结

### 项目优势

1. **严格遵循Clean Architecture**
   - 清晰的分层结构
   - 依赖倒置原则的正确应用
   - 边界接口的恰当使用

2. **良好的职责分离**
   - 每个类职责单一明确
   - 层间通过接口通信
   - 实体层完全独立

3. **可测试性强**
   - 核心业务逻辑独立于框架
   - 接口抽象便于mock
   - 数据传输对象清晰

4. **可维护性好**
   - 代码结构清晰
   - 命名规范
   - 注释适当

5. **用户体验优秀**
   - 类别选择功能
   - 即时反馈（颜色高亮）
   - 自动前进机制

### 技术栈

- **语言**: Java 11
- **UI框架**: Swing
- **构建工具**: Maven
- **数据格式**: JSON
- **设计模式**: 
  - Clean Architecture
  - 观察者模式（PropertyChangeListener）
  - 依赖注入
  - 边界对象模式
  - 数据访问对象（DAO）模式

### 学习价值

这个项目是学习Clean Architecture的优秀案例，展示了：
- 如何在小型项目中应用企业级架构
- 如何正确划分层次和职责
- 如何通过接口实现依赖倒置
- 如何使用观察者模式解耦View和Model
- 如何进行依赖注入

### 扩展性

当前架构支持以下扩展：
1. 添加更多问题类别
2. 实现不同的数据源（数据库、网络API）
3. 添加多语言支持
4. 实现成绩持久化
5. 添加用户认证系统
6. 实现在线多人模式

只需要在对应层添加或替换实现，无需修改核心业务逻辑。

---

**文档版本**: 1.0  
**基于分支**: Multiple_Choice_Yihang2  
**文档日期**: 2024  
**作者**: 基于Jiayi和Yihang的源代码分析
